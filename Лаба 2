#pragma warning(disable : 4996)
#include <iostream>
using namespace std;

struct stroki {
private:
	size_t m_size = 1;
	char*m_str = nullptr; // Чтобы диструктор не ругался //
	friend ostream& operator << (ostream& fout, stroki& str);
	friend ostream& operator >> (ostream& fin, stroki& str);
public:
	// Конструктор по умолчанию //
	stroki() {
		cout << "default Constructor" << endl;
		size_t m_size = 0;
		m_str = 0;
	}
	// Конструктор запрещен //
	stroki(int s, size_t size) = delete; 
	// Преобразования из int в char //
	stroki(char s, size_t size) : m_size(size), m_str(new char[size+1]) { 
		cout << "Constructor1" << endl;
		fill(m_str, m_str + m_size, s);
		m_str[m_size] = 0;
	}
	// Список инициализаций членов класса //
	stroki(char* str) : m_size(strlen(str)), m_str(new char[m_size+1]) { 
		cout << "Constructor2 " << str<< endl;
		copy(str, str + m_size, m_str); 
		m_str[m_size] = 0;
	}
	// Конструктор копирования + Дилигирующий конструктор //
	stroki(const stroki& other):stroki(other.m_str) { 
		cout << "Copy Constructor" << endl;
	}
	stroki& operator = (const stroki& other) {
		cout << "Copy assigment operator" << endl;
		delete[] m_str;
		m_size = other.m_size;
		m_str = new char[m_size];
		copy(other.m_str, other.m_str + other.m_size, m_str);
		return *this;
	}
	stroki& operator +=(const stroki& other) { //a=a+b
		cout << "Pereopredelenie operator" << endl;
		char* newstr = new char[m_size + other.m_size+1];
		copy(m_str, m_str + m_size, newstr);
		copy(other.m_str, other.m_str + other.m_size+1, newstr+m_size);
		delete[] m_str;
		m_str = newstr;
		m_size = strlen(m_str);
		return *this;
	}
	stroki operator + (const stroki& other) { // c=a+b
		cout << "Summa operator" << endl;
		char* newstr = new char[m_size + other.m_size + 1];
		copy(m_str, m_str + m_size, newstr);
		copy(other.m_str, other.m_str + other.m_size + 1, newstr + m_size);
		stroki a(newstr);
		return a;
	}
	char operator [] (int number) {
		cout << "Number operator" << endl;
		return char(m_str[number]);
	}
	bool operator > ( const stroki& other) {
		return strcmp(m_str, other.m_str) > 0;
	}
	bool operator == (const stroki& other) {
		return strcmp(m_str, other.m_str) == 0;
	}
	bool operator < (const stroki& other) {
		return strcmp(m_str, other.m_str) < 0;
	}

	char* c_str() {
		return m_str;
	}
	int length () {
		cout << "Length operator" << endl;
		return m_size;
	}
	int find (char symbol){
		for (int i = 0; i < m_size; i++) {
			if (m_str[i] == symbol) {
				return i;
			}
		}
		return -1;
	}
	// Диструктор //
	~stroki() {
		cout << "Destructor" << endl;
		if (m_str != nullptr) {
			delete[] m_str; } 
	}
	// Константный метод //
	size_t Size() const { 
		return m_size;
	}
	void Print() const{
		cout << endl;
		cout << endl;
		cout << endl;
		for (int i = 0; i < m_size; i++) {
			cout << m_str[i];
		}
		cout << endl;
		cout << endl;
		cout << endl;
	}
};

ostream& operator << (ostream& fout, stroki& str) {
	for (int i = 0; i < str.m_size; i++) {
		fout << str.m_str[i];
	}
	fout << endl;
	return fout;
}
ostream& operator >> (ostream& fin, stroki& str) {

}
int main() {
	stroki s1 ("LOLAOLAOLA");
	stroki s2 ("lololo");
	stroki s3 = s1 + s2;
	s1.Print();
	cout << s1.c_str() << endl;
	system("pause");
}
